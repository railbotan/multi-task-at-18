# Параллелизм и асинхронность

## IO-bound

Синхронно в 1 поток:
![img](img/sync.png)

5 воркеров:
![img](img/five.png)
![img](img/mem_5.png)

10 воркеров:
![img](img/ten.png)
![img](img/mem_10.png)

100 воркеров:
![img](img/hundred.png)
![img](img/mem_100.png)


Количество задействованной памяти и нагрузка на ЦП почти 
не изменяется, так как из-за большого количества воркеров 
происходит быстрое взаимодействие с сетью.

## CPU-bound

Генерация на 1 ядре для 4 монет:
![img](img/gen1.png)

2 воркера для 4 монет:
![img](img/two.png)
![img](img/mem_2c.png)

4 воркера для 4 монет:
![img](img/four.png)
![img](img/mem_4c.png)

5 воркеров для 4 монет:
![img](img/fiveC.png)
![img](img/mem_5c.png)

10 воркеров для 4 монет:
![img](img/tenC.png)
![img](img/mem_10c.png)

100 воркеров для 4 монет:
Будет выдавать ошибку, так как есть ограничение в 61 воркер
![img](img/error.png)

Протестировав программу пару раз, я пришел к выводу, 
что увеличение или уменьшение кол-ва воркеров никак
не влияет на конечное время работы программы. Загруженность ЦП
никак не мог нормально уловить, так как программа буквально
за считанные секунды выполняла работу. Такой разброс во времени
обусловлен рандомным нахождением нужных нам монет.
(Процессор 6 ядер 12 потоков)